"
I run a block in a separate image and communicate the value back using OSProcess.
Exceptions are properly serialized in the remote image and locally resignalled, as if the block were evaluated locally.

Example:
	CIImageWorkder do: [ 1 + 2 ].
	CIImageWorker do: [ 1 / 0 ].
"
Class {
	#name : #ImageWorker,
	#superclass : #Object,
	#instVars : [
		'timeout',
		'baseFile',
		'block',
		'session',
		'forkedImageProcess'
	],
	#category : #ImageWorker
}

{ #category : #api }
ImageWorker class >> do: aBlock [
	^ self new 
		block: aBlock;
		value
]

{ #category : #accessing }
ImageWorker >> baseFile [
	^ baseFile
]

{ #category : #accessing }
ImageWorker >> block [
	^ block
]

{ #category : #accessing }
ImageWorker >> block: aBlock [
	block := aBlock
]

{ #category : #'private - cleanup' }
ImageWorker >> cleanUp [
	forkedImageProcess isComplete
		ifFalse: [  forkedImageProcess terminate ].
	
	self baseFile parent deleteAll.
]

{ #category : #'private - forked image' }
ImageWorker >> evaluateBlock [
	| result isError errorRootContext |
	self logMethod.
	self runSafely: [
		isError := false.
		[ 
			errorRootContext := thisContext.
			result := block value 
		] on: Error do: [ :error |
				isError := true.
				"We do not care about the contexts in between generated by the CIImageWorker"
				result := error freezeUpTo: errorRootContext ].
			
		self serializeResult: result isError: isError ]
]

{ #category : #private }
ImageWorker >> forkImage [
	self logMethod.
	self updateSession.
	"Trying to avoid running any commandline handlers when running the forked image"
	Smalltalk backupTo: self baseFile fullName.
	FileStream startUp: true.
	
	self logMethod.
	VTermOutputDriver stdout 
		red: Smalltalk imageName; 
		lf.
	NonInteractiveTranscript allInstancesDo: [ :each | each initializeStream ].
]

{ #category : #accessing }
ImageWorker >> forkedChangesFile [
	^ self baseFile, Smalltalk image changesSuffix
]

{ #category : #accessing }
ImageWorker >> forkedImageCommand [
	^ Smalltalk vm command, ' "', self forkedImageFile fullName, '" --no-quit'
]

{ #category : #accessing }
ImageWorker >> forkedImageFile [
	^ self baseFile, Smalltalk image imageSuffix
]

{ #category : #logging }
ImageWorker >> inform: anObject [
	VTermOutputDriver stdout yellow: anObject asString; lf.
]

{ #category : #initialize }
ImageWorker >> initialize [

	super initialize.
	baseFile :=  Time primUTCMicrosecondsClock  asString asFileReference / Smalltalk imageFile nextVersion basenameWithoutExtension.
	timeout := 20 minutes.
]

{ #category : #testing }
ImageWorker >> isForkedImage [
	^ session ~~ Smalltalk session
]

{ #category : #logging }
ImageWorker >> logMethod [
	FileStream stdout nextPutAll: thisContext sender method printString; lf.
]

{ #category : #accessing }
ImageWorker >> name [
	^ baseFile basename
]

{ #category : #private }
ImageWorker >> readForkedImageResult [
	"The result is a serialized Array with the result at the first position, and a boolean to indicate whether the result is an exception or not"
	| result |
	self resultFile exists
		ifFalse: [ 
			self inform: 'Forked Image did not produce result'.
			^ Error signal: 'Forked Image did not produce result' ].
	result := FLMaterializer materializeFromFileNamed: self resultFile fullName.
	result second 
		ifTrue: [ self resignalRemoteError: result first ]
		ifFalse: [ ^ result first ]
]

{ #category : #private }
ImageWorker >> remoteErrorRootContext [
	"Return the context from which a remote error should be thrown"
	^ (thisContext findContextSuchThat: [ :context |
		 context method = (self class >> #value) ]) sender
]

{ #category : #private }
ImageWorker >> resignalRemoteError: remoteError [
	"Resignal the remote error as if it were caused in the #value method of the CIImageWorker.
	Note that the remote image pruned the stack up to the #evaluateBlock method."
	| signalerContext |
	
	signalerContext := self remoteErrorRootContext.
	"1. reattach the outermost context of the remote error to the current context"
	remoteError signalerContext bottomContext privSender: signalerContext.
	
	"2. Make sure we start the error handler lookup in the current context chain"
	remoteError privHandlerContext: signalerContext.
	
	"3. pass/resignal the remote error"
	self cleanUp.
	remoteError pass.
]

{ #category : #accessing }
ImageWorker >> resultFile [
	^ self baseFile, 'fuel'
]

{ #category : #private }
ImageWorker >> runForkedImage [
	self logMethod.
	[[ self waitForForkedImage ]
		valueWithin: self timeout onTimeout: [ 
			Error signal: 'Timeout Occurred' ].
		^ self readForkedImageResult
	] ensure: [ self cleanUp ]
]

{ #category : #'private - forked image' }
ImageWorker >> runSafely: aBlock [
	self inform: 'runSafely:'.
	"Make sure we can run aBlock without side-effects "
	[ aBlock ensure: [
		"Make sure that we always quit the image after running the block and serializing its contents."
		Smalltalk exitSuccess.
		Error signal: 'Do not reopen a forked image' ]
	] fork.
	"We have to make sure to block the current process to avoid side-effects"
	self terminateActiveProcess.
]

{ #category : #'private - forked image' }
ImageWorker >> serializeResult: result isError: isError [
	[
		{ result. isError } serializeToFileNamed: self resultFile fullName 
	] on: Error do: [ :error |
		self inform: 'Could not serialize result ', error messageText.
		error pass ]
]

{ #category : #'private - forked image' }
ImageWorker >> terminateActiveProcess [
	"Terminate the current UI process in the freshly spawned image.
	This way we can be sure to not have any nast side-effects from the pending stack.
	The forked  image will contain the full stack of the original image, thus it is not guaranteed that the exuction in the new image is properly stopped."
	 
	| currentProcess semaphore |

	semaphore := Semaphore new.
	currentProcess := Processor activeProcess.

	[ 
		"suspend the current UI process, terminating it would cause all pending #ensure: blocks to be evaluated which can cause unwanted side-effects"
		self inform: 'terminateActiveProcess'.
		[ currentProcess suspend ] on: Error do: [ :error | ].
		WorldState deferredUIMessages flush.
		semaphore signal.
	] fork.

	semaphore wait.
	Error signal: 'Should not get here'
]

{ #category : #accessing }
ImageWorker >> timeout [
	^ timeout
]

{ #category : #accessing }
ImageWorker >> timeout: anObject [
	timeout := anObject asDuration
]

{ #category : #action }
ImageWorker >> updateSession [
	session := Smalltalk session.
]

{ #category : #action }
ImageWorker >> value [
	self logMethod.
	"Evalute the block for this CIImageWorker in a separate image and returns its result"
	self forkImage.
	"This code is run in the forked image (new session) and in the current image (old session)"
	^ self isForkedImage
		ifTrue: [ 
			"In the forked (new session) evaluate the block"
			self evaluateBlock ]
		ifFalse: [ 
			"In the current image (old session) we wait for the forked image to return a result"
			self runForkedImage ]
]

{ #category : #private }
ImageWorker >> waitForForkedImage [
	| delay |
	self logMethod.
	self inform: 'Running: ', self forkedImageCommand.
	forkedImageProcess := OSProcess command: self forkedImageCommand.
	delay := 50 milliSeconds asDelay.
	[ forkedImageProcess isComplete ] whileFalse: [ delay wait ].

	forkedImageProcess succeeded
		ifFalse: [ Error signal: 'External Image Failed: ', forkedImageProcess exitStatus asString ]
]
